//! Template definitions for scaffold code generation
//!
//! This module contains Handlebars templates for generating:
//! - `SeaORM` models with validation
//! - Database migrations
//! - Form structs
//! - HTMX handlers
//! - Askama templates
//! - Integration tests
//! - Route registration
//!
//! Templates use Handlebars syntax with custom helpers for naming conventions.

use handlebars::Handlebars;
use anyhow::{Context, Result};
use crate::template_manager::TemplateManager;

/// Template registry for scaffold code generation
pub struct TemplateRegistry {
    handlebars: Handlebars<'static>,
}

impl TemplateRegistry {
    /// Create a new template registry with all scaffold templates registered
    ///
    /// Templates are loaded from the XDG config directory (`~/.config/acton-htmx/templates/scaffold/`)
    /// or downloaded from GitHub if not present.
    ///
    /// # Errors
    ///
    /// Returns an error if templates cannot be loaded or registered.
    pub fn new() -> Result<Self> {
        // Ensure templates are available locally
        let template_manager = TemplateManager::new()
            .context("Failed to initialize template manager")?;
        template_manager.ensure_templates()
            .context("Failed to ensure templates are available")?;

        let mut handlebars = Handlebars::new();

        // Disable HTML escaping for code generation
        handlebars.register_escape_fn(handlebars::no_escape);

        // Register templates from filesystem
        Self::register_template_file(&mut handlebars, &template_manager, "model", "model.rs.hbs")?;
        Self::register_template_file(&mut handlebars, &template_manager, "migration", "migration.sql.hbs")?;
        Self::register_template_file(&mut handlebars, &template_manager, "form", "form.rs.hbs")?;
        Self::register_template_file(&mut handlebars, &template_manager, "handler", "handler.rs.hbs")?;
        Self::register_template_file(&mut handlebars, &template_manager, "test", "test.rs.hbs")?;

        // Askama templates (HTML) are rendered separately in generate_templates()
        // They are loaded directly from files, not registered in Handlebars

        Ok(Self { handlebars })
    }

    /// Register a template from a file in the cache directory
    fn register_template_file(
        handlebars: &mut Handlebars<'static>,
        template_manager: &TemplateManager,
        name: &str,
        filename: &str,
    ) -> Result<()> {
        let path = template_manager.get_template_path(filename)?;
        let content = std::fs::read_to_string(&path)
            .with_context(|| format!("Failed to read template file: {}", path.display()))?;

        handlebars.register_template_string(name, content)
            .with_context(|| format!("Failed to register template '{name}' from {filename}"))?;

        Ok(())
    }

    /// Render a template with the given data
    ///
    /// # Errors
    ///
    /// Returns an error if the template name is not registered or if rendering fails.
    pub fn render(&self, template_name: &str, data: &serde_json::Value) -> Result<String> {
        Ok(self.handlebars.render(template_name, data)?)
    }
}

impl Default for TemplateRegistry {
    fn default() -> Self {
        Self::new().expect("Failed to create template registry")
    }
}

// Template constants - will be populated in Week 2-3

/// `SeaORM` model template
pub const MODEL_TEMPLATE: &str = r#"//! {{model_name}} model
//!
//! Generated by acton-htmx scaffold

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
{{#if has_date_fields}}
use chrono::{NaiveDate, NaiveDateTime, DateTime, Utc};
{{/if}}
{{#if has_decimal}}
use rust_decimal::Decimal;
{{/if}}
{{#if has_uuid}}
use uuid::Uuid;
{{/if}}
{{#if has_enum}}

{{#each enums}}
/// {{name}} enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(50))")]
pub enum {{name}} {
    {{#each variants}}
    #[sea_orm(string_value = "{{this}}")]
    {{this}},
    {{/each}}
}
{{/each}}
{{/if}}

/// {{model_name}} entity
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "{{table_name}}")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[serde(skip_deserializing)]
    pub id: i64,
    {{#each fields}}
    {{#if unique}}
    #[sea_orm(unique)]
    {{/if}}
    {{#if indexed}}
    #[sea_orm(indexed)]
    {{/if}}
    pub {{name}}: {{rust_type}},
    {{/each}}
    #[serde(skip_deserializing)]
    pub created_at: DateTime<Utc>,
    #[serde(skip_deserializing)]
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    {{#each relations}}
    #[sea_orm(
        belongs_to = "super::{{referenced_table}}::Entity",
        from = "Column::{{field_column}}",
        to = "super::{{referenced_table}}::Column::Id"
    )]
    {{relation_name}},
    {{/each}}
}

{{#each relations}}
impl Related<super::{{referenced_table}}::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::{{relation_name}}.def()
    }
}
{{/each}}

impl ActiveModelBehavior for ActiveModel {}

impl Entity {
    /// Find all {{plural_title}}
    pub async fn find_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        Self::find().all(db).await
    }

    /// Find {{model_name}} by ID
    pub async fn find_by_id(db: &DatabaseConnection, id: i64) -> Result<Option<Model>, DbErr> {
        Self::find_by_id(id).one(db).await
    }

    /// Create new {{model_name}}
    pub async fn create(db: &DatabaseConnection, form: super::forms::{{model_name}}Form) -> Result<Model, DbErr> {
        let model = ActiveModel {
            {{#each fields}}
            {{name}}: Set(form.{{name}}),
            {{/each}}
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
            ..Default::default()
        };
        model.insert(db).await
    }

    /// Update {{model_name}}
    pub async fn update(db: &DatabaseConnection, id: i64, form: super::forms::{{model_name}}Form) -> Result<Model, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        let mut active_model: ActiveModel = model.into();
        {{#each fields}}
        active_model.{{name}} = Set(form.{{name}});
        {{/each}}
        active_model.updated_at = Set(Utc::now());
        active_model.update(db).await
    }

    /// Delete {{model_name}}
    pub async fn delete(db: &DatabaseConnection, id: i64) -> Result<DeleteResult, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        model.delete(db).await
    }
}
"#;

/// Database migration template
pub const MIGRATION_TEMPLATE: &str = r"-- Create {{table_name}} table
-- Generated by acton-htmx scaffold

CREATE TABLE {{table_name}} (
    id BIGSERIAL PRIMARY KEY,
    {{#each fields}}
    {{column_name}} {{sql_type}}{{#unless optional}} NOT NULL{{/unless}},
    {{/each}}
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

{{#each unique_fields}}
-- Add unique constraint for {{name}}
ALTER TABLE {{../table_name}} ADD CONSTRAINT {{../table_name}}_{{name}}_unique UNIQUE ({{column_name}});
{{/each}}

{{#each indexed_fields}}
-- Add index for {{name}}
CREATE INDEX {{../table_name}}_{{name}}_idx ON {{../table_name}} ({{column_name}});
{{/each}}

{{#each foreign_keys}}
-- Add foreign key for {{field_name}}
ALTER TABLE {{../table_name}}
    ADD CONSTRAINT {{../table_name}}_{{field_name}}_fkey
    FOREIGN KEY ({{column_name}})
    REFERENCES {{referenced_table}}(id)
    ON DELETE CASCADE;

-- Add index for foreign key
CREATE INDEX {{../table_name}}_{{field_name}}_idx ON {{../table_name}} ({{column_name}});
{{/each}}

-- Trigger to automatically update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_{{table_name}}_updated_at
    BEFORE UPDATE ON {{table_name}}
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
";

/// HTMX handler template
pub const HANDLER_TEMPLATE: &str = r#"//! {{model_name}} handlers
//!
//! Generated by acton-htmx scaffold

use acton_htmx::prelude::*;
use askama::Template;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    Form,
};
use serde::Deserialize;
use validator::Validate;

use crate::{
    forms::{{model_snake}}::{{model_name}}Form,
    models::{{model_snake}},
    state::AppState,
};

/// List all {{plural_title}}
pub async fn list(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Query(params): Query<ListParams>,
) -> Result<Response, HandlerError> {
    let {{model_snake}}s = {{model_snake}}::Entity::find_all(&state.db).await?;

    let template = {{model_name}}ListTemplate {
        {{model_snake}}s,
        search_query: params.search.unwrap_or_default(),
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Show individual {{model_name}}
pub async fn show(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    let {{model_snake}} = {{model_snake}}::Entity::find_by_id(&state.db, id)
        .await?
        .ok_or(HandlerError::NotFound)?;

    let template = {{model_name}}ShowTemplate { {{model_snake}} };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Show new {{model_name}} form
pub async fn new(
    HxRequest(is_htmx): HxRequest,
) -> Result<Response, HandlerError> {
    let template = {{model_name}}FormTemplate {
        {{model_snake}}: None,
        errors: None,
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Create new {{model_name}}
pub async fn create(
    State(state): State<AppState>,
    mut session: Session,
    Form(form): Form<{{model_name}}Form>,
) -> Result<Response, HandlerError> {
    // Validate form
    if let Err(errors) = form.validate() {
        let template = {{model_name}}FormTemplate {
            {{model_snake}}: None,
            errors: Some(errors.into()),
        };
        return Ok((StatusCode::UNPROCESSABLE_ENTITY, template.render_partial()).into_response());
    }

    // Create {{model_snake}}
    let {{model_snake}} = {{model_snake}}::Entity::create(&state.db, form).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{model_name}} created successfully!"));

    // Redirect to show page
    Ok(HxRedirect::to(&format!("{{route_path}}/{}", {{model_snake}}.id)).into_response())
}

/// Show edit {{model_name}} form
pub async fn edit(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    let {{model_snake}} = {{model_snake}}::Entity::find_by_id(&state.db, id)
        .await?
        .ok_or(HandlerError::NotFound)?;

    let template = {{model_name}}FormTemplate {
        {{model_snake}}: Some({{model_snake}}),
        errors: None,
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Update {{model_name}}
pub async fn update(
    State(state): State<AppState>,
    mut session: Session,
    Path(id): Path<i64>,
    Form(form): Form<{{model_name}}Form>,
) -> Result<Response, HandlerError> {
    // Validate form
    if let Err(errors) = form.validate() {
        let {{model_snake}} = {{model_snake}}::Entity::find_by_id(&state.db, id)
            .await?
            .ok_or(HandlerError::NotFound)?;

        let template = {{model_name}}FormTemplate {
            {{model_snake}}: Some({{model_snake}}),
            errors: Some(errors.into()),
        };
        return Ok((StatusCode::UNPROCESSABLE_ENTITY, template.render_partial()).into_response());
    }

    // Update {{model_snake}}
    let {{model_snake}} = {{model_snake}}::Entity::update(&state.db, id, form).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{model_name}} updated successfully!"));

    // Return updated row with OOB swap
    let row_template = {{model_name}}RowTemplate { {{model_snake}}: {{model_snake}}.clone() };
    let flash_template = FlashMessagesTemplate { messages: session.take_flashes() };

    Ok(HxSwapOob::new()
        .inner_html(&format!(\"{{model_snake}}-{}\", {{model_snake}}.id), &row_template.render_partial())
        .inner_html(\"flash-messages\", &flash_template.render_partial())
        .into_response())
}

/// Delete {{model_name}}
pub async fn delete(
    State(state): State<AppState>,
    mut session: Session,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    {{model_snake}}::Entity::delete(&state.db, id).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{model_name}} deleted successfully!"));

    // Return empty response with OOB swap to remove row and show flash
    let flash_template = FlashMessagesTemplate { messages: session.take_flashes() };

    Ok(HxSwapOob::new()
        .delete(&format!(\"{{model_snake}}-{id}\"))
        .inner_html(\"flash-messages\", &flash_template.render_partial())
        .into_response())
}

/// Live search endpoint
pub async fn search(
    State(state): State<AppState>,
    Query(params): Query<SearchParams>,
) -> Result<Response, HandlerError> {
    // TODO: Implement search functionality with your preferred method
    let {{model_snake}}s = {{model_snake}}::Entity::find_all(&state.db).await?;

    let template = {{model_name}}RowsTemplate { {{model_snake}}s };

    Ok(template.render_partial().into_response())
}

// Query parameters
#[derive(Debug, Deserialize)]
pub struct ListParams {
    pub search: Option<String>,
    pub page: Option<i64>,
}

#[derive(Debug, Deserialize)]
pub struct SearchParams {
    pub q: String,
}

// Templates
#[derive(Template)]
#[template(path = \"{{model_snake}}s/list.html\")]
struct {{model_name}}ListTemplate {
    {{model_snake}}s: Vec<{{model_snake}}::Model>,
    search_query: String,
}

#[derive(Template)]
#[template(path = \"{{model_snake}}s/show.html\")]
struct {{model_name}}ShowTemplate {
    {{model_snake}}: {{model_snake}}::Model,
}

#[derive(Template)]
#[template(path = \"{{model_snake}}s/form.html\")]
struct {{model_name}}FormTemplate {
    {{model_snake}}: Option<{{model_snake}}::Model>,
    errors: Option<ValidationErrors>,
}

#[derive(Template)]
#[template(path = \"{{model_snake}}s/_row.html\")]
struct {{model_name}}RowTemplate {
    {{model_snake}}: {{model_snake}}::Model,
}

#[derive(Template)]
#[template(path = \"{{model_snake}}s/_rows.html\")]
struct {{model_name}}RowsTemplate {
    {{model_snake}}s: Vec<{{model_snake}}::Model>,
}

#[derive(Template)]
#[template(path = \"partials/flash.html\")]
struct FlashMessagesTemplate {
    messages: Vec<FlashMessage>,
}

// Error handling
#[derive(Debug)]
pub enum HandlerError {
    Database(sea_orm::DbErr),
    NotFound,
}

impl From<sea_orm::DbErr> for HandlerError {
    fn from(err: sea_orm::DbErr) -> Self {
        Self::Database(err)
    }
}

impl IntoResponse for HandlerError {
    fn into_response(self) -> Response {
        match self {
            Self::Database(err) => {
                (StatusCode::INTERNAL_SERVER_ERROR, format!(\"Database error: {err}\")).into_response()
            }
            Self::NotFound => {
                (StatusCode::NOT_FOUND, \"Not found\").into_response()
            }
        }
    }
}
"#;

/// Form struct template
pub const FORM_TEMPLATE: &str = r"//! {{model_name}} form validation
//!
//! Generated by acton-htmx scaffold

use serde::{Deserialize, Serialize};
use validator::Validate;
{{#if has_date_fields}}
use chrono::{NaiveDate, NaiveDateTime, DateTime, Utc};
{{/if}}
{{#if has_decimal}}
use rust_decimal::Decimal;
{{/if}}
{{#if has_uuid}}
use uuid::Uuid;
{{/if}}
{{#if has_enum}}
use super::models::{{model_snake}}::{
    {{#each enums}}
    {{name}},
    {{/each}}
};
{{/if}}

/// {{model_name}} form for creation and updates
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct {{model_name}}Form {
    {{#each fields}}
    {{#if validations}}
    {{#each validations}}
    #[validate({{this}})]
    {{/each}}
    {{/if}}
    pub {{name}}: {{rust_type}},
    {{/each}}
}

impl {{model_name}}Form {
    /// Create a new form instance
    pub fn new(
        {{#each fields}}
        {{name}}: {{rust_type}},
        {{/each}}
    ) -> Self {
        Self {
            {{#each fields}}
            {{name}},
            {{/each}}
        }
    }

    /// Validate the form
    pub fn validate(&self) -> Result<(), validator::ValidationErrors> {
        Validate::validate(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_form_creation() {
        let form = {{model_name}}Form::new(
            {{#each fields}}
            {{#if optional}}
            None,
            {{else}}
            {{default_value}},
            {{/if}}
            {{/each}}
        );
        assert!(form.validate().is_ok());
    }
}
";

/// Integration test template
pub const TEST_TEMPLATE: &str = r#"//! Integration tests for {{model_name}} CRUD operations
//!
//! Generated by acton-htmx scaffold

use acton_htmx::prelude::*;
use axum::{
    body::Body,
    http::{Request, StatusCode},
};
use serde_json::json;
use tower::ServiceExt;

use crate::{
    models::{{model_snake}},
    state::AppState,
    app_router,
};

#[tokio::test]
async fn test_list_{{model_snake}}s() {
    let state = AppState::test().await;
    let app = app_router(state);

    let response = app
        .oneshot(
            Request::builder()
                .uri(\"{{route_path}}\")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_create_{{model_snake}}() {
    let state = AppState::test().await;
    let app = app_router(state.clone());

    // Create test {{model_snake}}
    let form_data = serde_urlencoded::to_string(&json!({
        {{#each fields}}
        \"{{name}}\": {{#if optional}}null{{else}}{{default_value}}{{/if}},
        {{/each}}
    }))
    .unwrap();

    let response = app
        .oneshot(
            Request::builder()
                .method(\"POST\")
                .uri(\"{{route_path}}\")
                .header(\"content-type\", \"application/x-www-form-urlencoded\")
                .body(Body::from(form_data))
                .unwrap(),
        )
        .await
        .unwrap();

    // Should redirect after creation
    assert!(response.status().is_redirection() || response.status().is_success());

    // Verify {{model_snake}} was created
    let {{model_snake}}s = {{model_snake}}::Entity::find_all(&state.db).await.unwrap();
    assert!(!{{model_snake}}s.is_empty());
}

#[tokio::test]
async fn test_show_{{model_snake}}() {
    let state = AppState::test().await;

    // Create test {{model_snake}}
    let form = crate::forms::{{model_snake}}::{{model_name}}Form::new(
        {{#each fields}}
        {{#if optional}}None{{else}}{{default_value}}{{/if}},
        {{/each}}
    );
    let {{model_snake}} = {{model_snake}}::Entity::create(&state.db, form).await.unwrap();

    let app = app_router(state);

    let response = app
        .oneshot(
            Request::builder()
                .uri(&format!(\"{{route_path}}/{}\", {{model_snake}}.id))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_update_{{model_snake}}() {
    let state = AppState::test().await;

    // Create test {{model_snake}}
    let form = crate::forms::{{model_snake}}::{{model_name}}Form::new(
        {{#each fields}}
        {{#if optional}}None{{else}}{{default_value}}{{/if}},
        {{/each}}
    );
    let {{model_snake}} = {{model_snake}}::Entity::create(&state.db, form).await.unwrap();

    let app = app_router(state.clone());

    // Update {{model_snake}}
    let form_data = serde_urlencoded::to_string(&json!({
        {{#each fields}}
        \"{{name}}\": {{#if optional}}null{{else}}{{default_value}}{{/if}},
        {{/each}}
    }))
    .unwrap();

    let response = app
        .oneshot(
            Request::builder()
                .method(\"PUT\")
                .uri(&format!(\"{{route_path}}/{}\", {{model_snake}}.id))
                .header(\"content-type\", \"application/x-www-form-urlencoded\")
                .body(Body::from(form_data))
                .unwrap(),
        )
        .await
        .unwrap();

    assert!(response.status().is_success());

    // Verify {{model_snake}} was updated
    let updated = {{model_snake}}::Entity::find_by_id(&state.db, {{model_snake}}.id)
        .await
        .unwrap()
        .expect(\"{{model_name}} should exist\");
    assert_eq!(updated.id, {{model_snake}}.id);
}

#[tokio::test]
async fn test_delete_{{model_snake}}() {
    let state = AppState::test().await;

    // Create test {{model_snake}}
    let form = crate::forms::{{model_snake}}::{{model_name}}Form::new(
        {{#each fields}}
        {{#if optional}}None{{else}}{{default_value}}{{/if}},
        {{/each}}
    );
    let {{model_snake}} = {{model_snake}}::Entity::create(&state.db, form).await.unwrap();

    let app = app_router(state.clone());

    let response = app
        .oneshot(
            Request::builder()
                .method(\"DELETE\")
                .uri(&format!(\"{{route_path}}/{}\", {{model_snake}}.id))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert!(response.status().is_success());

    // Verify {{model_snake}} was deleted
    let deleted = {{model_snake}}::Entity::find_by_id(&state.db, {{model_snake}}.id)
        .await
        .unwrap();
    assert!(deleted.is_none());
}

#[tokio::test]
async fn test_validation_errors() {
    let state = AppState::test().await;
    let app = app_router(state);

    // Attempt to create with invalid data
    let form_data = serde_urlencoded::to_string(&json!({})).unwrap();

    let response = app
        .oneshot(
            Request::builder()
                .method(\"POST\")
                .uri(\"{{route_path}}\")
                .header(\"content-type\", \"application/x-www-form-urlencoded\")
                .body(Body::from(form_data))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::UNPROCESSABLE_ENTITY);
}
"#;

/// Askama template for list view
pub const ASKAMA_LIST_TEMPLATE: &str = r##"{% extends "base.html" %}

{% block title %}{{plural_title}}{% endblock %}

{% block content %}
<!-- HTMX Content Start -->
<div id="main-content">
    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold">{{plural_title}}</h1>
            <a href="{{route_path}}/new"
               class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
               hx-get="{{route_path}}/new"
               hx-target="#main-content"
               hx-push-url="true">
                New {{model_name}}
            </a>
        </div>

        <!-- Flash Messages -->
        <div id="flash-messages" class="mb-4"></div>

        <!-- Search Bar -->
        <div class="mb-4">
            <input type="search"
                   name="search"
                   placeholder="Search {{plural_title}}..."
                   class="w-full px-4 py-2 border rounded"
                   hx-get="{{route_path}}/search"
                   hx-trigger="keyup changed delay:500ms, search"
                   hx-target="#{{model_snake}}-list"
                   hx-indicator=".htmx-indicator">
            <span class="htmx-indicator">Searching...</span>
        </div>

        <!-- {{model_name}} List -->
        <div class="bg-white shadow-md rounded">
            <table class="min-w-full">
                <thead class="bg-gray-200">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">ID</th>
                        {{#each fields}}
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">{{name}}</th>
                        {{/each}}
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Actions</th>
                    </tr>
                </thead>
                <tbody id="{{model_snake}}-list" class="bg-white divide-y divide-gray-200">
                    {% for {{model_snake}} in {{model_snake}}s %}
                        {% include "{{model_snake}}s/_row.html" %}
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>
<!-- HTMX Content End -->
{% endblock %}
"##;

/// Askama template for row partial
pub const ASKAMA_ROW_TEMPLATE: &str = r##"<tr id="{{model_snake}}-{{ {{model_snake}}.id }}">
    <td class="px-6 py-4 whitespace-nowrap">{{ {{model_snake}}.id }}</td>
    {{#each fields}}
    <td class="px-6 py-4 whitespace-nowrap">{{ {{../model_snake}}.{{name}} }}</td>
    {{/each}}
    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
        <a href="{{route_path}}/{{ {{model_snake}}.id }}"
           class="text-blue-600 hover:text-blue-900 mr-3"
           hx-get="{{route_path}}/{{ {{model_snake}}.id }}"
           hx-target="#main-content"
           hx-push-url="true">
            View
        </a>
        <a href="{{route_path}}/{{ {{model_snake}}.id }}/edit"
           class="text-indigo-600 hover:text-indigo-900 mr-3"
           hx-get="{{route_path}}/{{ {{model_snake}}.id }}/edit"
           hx-target="#main-content"
           hx-push-url="true">
            Edit
        </a>
        <button class="text-red-600 hover:text-red-900"
                hx-delete="{{route_path}}/{{ {{model_snake}}.id }}"
                hx-confirm="Are you sure you want to delete this {{model_snake}}?"
                hx-target="#{{model_snake}}-{{ {{model_snake}}.id }}"
                hx-swap="outerHTML swap:1s">
            Delete
        </button>
    </td>
</tr>
"##;

/// Askama template for rows partial (multiple rows for search)
pub const ASKAMA_ROWS_TEMPLATE: &str = r#"{% for {{model_snake}} in {{model_snake}}s %}
    {% include "{{model_snake}}s/_row.html" %}
{% endfor %}
"#;

/// Askama template for show view
pub const ASKAMA_SHOW_TEMPLATE: &str = r##"{{% extends "base.html" %}}

{{% block title %}}{{model_name}} #{{{{{{ {{model_snake}}.id }}}}}}{{% endblock %}}

{{% block content %}}
<!-- HTMX Content Start -->
<div id="main-content">
    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold">{{model_name}} #{{{{{{ {{model_snake}}.id }}}}}}</h1>
            <div>
                <a href="{{route_path}}/{{{{{{ {{model_snake}}.id }}}}}}/edit"
                   class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-2"
                   hx-get="{{route_path}}/{{{{{{ {{model_snake}}.id }}}}}}/edit"
                   hx-target="#main-content"
                   hx-push-url="true">
                    Edit
                </a>
                <a href="{{route_path}}"
                   class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
                   hx-get="{{route_path}}"
                   hx-target="#main-content"
                   hx-push-url="true">
                    Back to List
                </a>
            </div>
        </div>

        <!-- Flash Messages -->
        <div id="flash-messages" class="mb-4"></div>

        <div class="bg-white shadow-md rounded px-8 py-6">
            {{#each fields}}
            <div class="mb-4">
                <label class="block text-gray-700 text-sm font-bold mb-2">{{name}}:</label>
                <p class="text-gray-900">{{{{{{ {{../model_snake}}.{{name}} }}}}}}</p>
            </div>
            {{/each}}
            <div class="mb-4">
                <label class="block text-gray-700 text-sm font-bold mb-2">Created At:</label>
                <p class="text-gray-900">{{{{{{ {{model_snake}}.created_at }}}}}}</p>
            </div>
            <div class="mb-4">
                <label class="block text-gray-700 text-sm font-bold mb-2">Updated At:</label>
                <p class="text-gray-900">{{{{{{ {{model_snake}}.updated_at }}}}}}</p>
            </div>
        </div>
    </div>
</div>
<!-- HTMX Content End -->
{{% endblock %}}
"##;

/// Askama template for form view (new and edit)
pub const ASKAMA_FORM_TEMPLATE: &str = r##"{% extends "base.html" %}

{% block title %}{% if {{model_snake}} %}Edit{{else}}New{% endif %} {{model_name}}{% endblock %}

{% block content %}
<!-- HTMX Content Start -->
<div id="main-content">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6">{% if {{model_snake}} %}Edit{{else}}New{% endif %} {{model_name}}</h1>

        <!-- Flash Messages -->
        <div id="flash-messages" class="mb-4"></div>

        <div class="bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4">
            <form {% if {{model_snake}} %}
                      hx-put="{{route_path}}/{{ {{model_snake}}.id }}"
                  {% else %}
                      hx-post="{{route_path}}"
                  {% endif %}
                  hx-target="#main-content"
                  hx-push-url="true">

                {{#each fields}}
                <div class="mb-4">
                    <label for="{{name}}" class="block text-gray-700 text-sm font-bold mb-2">
                        {{name}}{{#unless optional}}*{{/unless}}
                    </label>
                    {{#if (eq rust_type "String")}}
                    <input type="text"
                           name="{{name}}"
                           id="{{name}}"
                           value="{% if {{../model_snake}} %}{{ {{../model_snake}}.{{name}} }}{% endif %}"
                           class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline {% if errors %}{% if errors.{{name}} %}border-red-500{% endif %}{% endif %}"
                           {{#unless optional}}required{{/unless}}>
                    {{else if (eq rust_type "bool")}}
                    <input type="checkbox"
                           name="{{name}}"
                           id="{{name}}"
                           {% if {{../model_snake}} %}{% if {{../model_snake}}.{{name}} %}checked{% endif %}{% endif %}
                           class="mr-2 leading-tight">
                    {{else}}
                    <input type="text"
                           name="{{name}}"
                           id="{{name}}"
                           value="{% if {{../model_snake}} %}{{ {{../model_snake}}.{{name}} }}{% endif %}"
                           class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline {% if errors %}{% if errors.{{name}} %}border-red-500{% endif %}{% endif %}"
                           {{#unless optional}}required{{/unless}}>
                    {{/if}}
                    {% if errors %}
                        {% if let Some(field_errors) = errors.{{name}} %}
                            <p class="text-red-500 text-xs italic mt-1">{{ field_errors[0] }}</p>
                        {% endif %}
                    {% endif %}
                </div>
                {{/each}}

                <div class="flex items-center justify-between">
                    <button type="submit"
                            class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        {% if {{model_snake}} %}Update{% else %}Create{% endif %} {{model_name}}
                    </button>
                    <a href="{{route_path}}"
                       class="inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800"
                       hx-get="{{route_path}}"
                       hx-target="#main-content"
                       hx-push-url="true">
                        Cancel
                    </a>
                </div>
            </form>
        </div>
    </div>
</div>
<!-- HTMX Content End -->
{% endblock %}
"##;
