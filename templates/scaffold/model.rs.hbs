//! {{model_name}} model
//!
//! Generated by acton-htmx scaffold

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
{{#if has_date_fields}}
use chrono::{NaiveDate, NaiveDateTime, DateTime, Utc};
{{/if}}
{{#if has_decimal}}
use rust_decimal::Decimal;
{{/if}}
{{#if has_uuid}}
use uuid::Uuid;
{{/if}}
{{#if has_enum}}

{{#each enums}}
/// {{name}} enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(50))")]
pub enum {{name}} {
    {{#each variants}}
    #[sea_orm(string_value = "{{this}}")]
    {{this}},
    {{/each}}
}
{{/each}}
{{/if}}

/// {{model_name}} entity
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "{{table_name}}")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[serde(skip_deserializing)]
    pub id: i64,
    {{#each fields}}
    {{#if unique}}
    #[sea_orm(unique)]
    {{/if}}
    {{#if indexed}}
    #[sea_orm(indexed)]
    {{/if}}
    pub {{name}}: {{rust_type}},
    {{/each}}
    #[serde(skip_deserializing)]
    pub created_at: DateTime<Utc>,
    #[serde(skip_deserializing)]
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    {{#each relations}}
    #[sea_orm(
        belongs_to = "super::{{referenced_table}}::Entity",
        from = "Column::{{field_column}}",
        to = "super::{{referenced_table}}::Column::Id"
    )]
    {{relation_name}},
    {{/each}}
}

{{#each relations}}
impl Related<super::{{referenced_table}}::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::{{relation_name}}.def()
    }
}
{{/each}}

impl ActiveModelBehavior for ActiveModel {}

impl Entity {
    /// Find all {{plural_title}}
    pub async fn find_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        Self::find().all(db).await
    }

    /// Find {{model_name}} by ID
    pub async fn find_by_id(db: &DatabaseConnection, id: i64) -> Result<Option<Model>, DbErr> {
        Self::find_by_id(id).one(db).await
    }

    /// Create new {{model_name}}
    pub async fn create(db: &DatabaseConnection, form: super::forms::{{model_name}}Form) -> Result<Model, DbErr> {
        let model = ActiveModel {
            {{#each fields}}
            {{name}}: Set(form.{{name}}),
            {{/each}}
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
            ..Default::default()
        };
        model.insert(db).await
    }

    /// Update {{model_name}}
    pub async fn update(db: &DatabaseConnection, id: i64, form: super::forms::{{model_name}}Form) -> Result<Model, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        let mut active_model: ActiveModel = model.into();
        {{#each fields}}
        active_model.{{name}} = Set(form.{{name}});
        {{/each}}
        active_model.updated_at = Set(Utc::now());
        active_model.update(db).await
    }

    /// Delete {{model_name}}
    pub async fn delete(db: &DatabaseConnection, id: i64) -> Result<DeleteResult, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        model.delete(db).await
    }
}
