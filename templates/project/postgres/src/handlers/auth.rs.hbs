//! Authentication handlers with `PostgreSQL` database integration
//!
//! Provides login, registration, and logout functionality with:
//! - Argon2id password hashing
//! - Session-based authentication
//! - Flash messages for user feedback
//! - Form validation
//! - HTMX out-of-band swaps for seamless updates

use crate::AppState;
use acton_dx::prelude::*;
use acton_dx::auth::{FlashMessage, hash_password, verify_password};
use askama::Template;
use axum::{
    extract::State,
    response::{Html, IntoResponse, Response},
    Form,
};
use serde::Deserialize;

/// User row from `PostgreSQL` database
#[derive(Debug, Clone, sqlx::FromRow)]
struct UserRow {
    id: i64,
    first_name: String,
    password_hash: String,
}

// =============================================================================
// Templates
// =============================================================================

#[derive(Template)]
#[template(path = "auth/login.html")]
pub struct LoginTemplate {
    pub user_id: Option<i64>,
    pub user_name: Option<String>,
    pub error: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

#[derive(Template)]
#[template(path = "auth/register.html")]
pub struct RegisterTemplate {
    pub user_id: Option<i64>,
    pub user_name: Option<String>,
    pub error: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

/// Response template for successful login/register with OOB swaps
#[derive(Template)]
#[template(path = "partials/auth_success.html")]
pub struct AuthSuccessTemplate {
    pub user_id: Option<i64>,
    pub user_name: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

/// Response template for successful logout with OOB swaps
#[derive(Template)]
#[template(path = "partials/logout_success.html")]
pub struct LogoutSuccessTemplate {
    pub error: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

// =============================================================================
// Form Data
// =============================================================================

#[derive(Debug, Deserialize)]
pub struct LoginForm {
    pub email: String,
    pub password: String,
}

#[derive(Debug, Deserialize)]
pub struct RegisterForm {
    pub first_name: String,
    pub email: String,
    pub password: String,
    pub password_confirm: String,
}

// =============================================================================
// Helpers
// =============================================================================

/// Create a registration error response
fn register_error(message: &str) -> Response {
    let template = RegisterTemplate {
        user_id: None,
        user_name: None,
        error: Some(message.to_string()),
        flash_messages: vec![],
    };
    Html(template.render().unwrap()).into_response()
}

// =============================================================================
// Handlers
// =============================================================================

/// GET /login - Show login form
pub async fn login_form(
    session: SessionExtractor,
) -> Html<String> {
    let template = LoginTemplate {
        user_id: session.1.user_id,
        user_name: session.1.user_name,
        error: None,
        flash_messages: session.1.flash_messages,
    };
    Html(template.render().unwrap())
}

/// POST /login - Process login
pub async fn login(
    State(state): State<AppState>,
    mut session: SessionExtractor,
    Form(form): Form<LoginForm>,
) -> Response {
    // Validate form
    if form.email.is_empty() || form.password.is_empty() {
        let template = LoginTemplate {
            user_id: None,
            user_name: None,
            error: Some("Email and password are required".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    // Find user by email
    let user = match sqlx::query_as::<_, UserRow>(
        "SELECT id, first_name, password_hash FROM users WHERE email = $1"
    )
    .bind(form.email.to_lowercase())
    .fetch_optional(state.db())
    .await
    {
        Ok(Some(user)) => user,
        Ok(None) => {
            let template = LoginTemplate {
                user_id: None,
                user_name: None,
                error: Some("Invalid email or password".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
        Err(e) => {
            tracing::error!("Database error during login: {}", e);
            let template = LoginTemplate {
                user_id: None,
                user_name: None,
                error: Some("An error occurred. Please try again.".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
    };

    // Verify password
    if matches!(verify_password(&form.password, &user.password_hash), Ok(true)) {
        // Set user info in session
        session.1.user_id = Some(user.id);
        session.1.user_name = Some(user.first_name.clone());

        // Return OOB response with updated nav, content, and flash
        let template = AuthSuccessTemplate {
            user_id: Some(user.id),
            user_name: Some(user.first_name.clone()),
            flash_messages: vec![FlashMessage::success(format!("Welcome back, {}!", user.first_name))],
        };
        Html(template.render().unwrap()).into_response()
    } else {
        let template = LoginTemplate {
            user_id: None,
            user_name: None,
            error: Some("Invalid email or password".to_string()),
            flash_messages: vec![],
        };
        Html(template.render().unwrap()).into_response()
    }
}

/// GET /register - Show registration form
pub async fn register_form(
    session: SessionExtractor,
) -> Html<String> {
    let template = RegisterTemplate {
        user_id: session.1.user_id,
        user_name: session.1.user_name,
        error: None,
        flash_messages: session.1.flash_messages,
    };
    Html(template.render().unwrap())
}

/// POST /register - Process registration
pub async fn register(
    State(state): State<AppState>,
    mut session: SessionExtractor,
    Form(form): Form<RegisterForm>,
) -> Response {
    // Validate form
    if form.first_name.trim().is_empty() {
        return register_error("First name is required");
    }
    if form.email.is_empty() {
        return register_error("Email is required");
    }
    if form.password.len() < 8 {
        return register_error("Password must be at least 8 characters");
    }
    if form.password != form.password_confirm {
        return register_error("Passwords do not match");
    }

    // Check if email already exists
    let exists = sqlx::query_scalar::<_, i32>("SELECT 1 FROM users WHERE email = $1")
        .bind(form.email.to_lowercase())
        .fetch_optional(state.db())
        .await;

    if matches!(exists, Ok(Some(_))) {
        return register_error("Email already registered");
    }

    // Hash password
    let password_hash = match hash_password(&form.password) {
        Ok(hash) => hash,
        Err(e) => {
            tracing::error!("Password hashing failed: {}", e);
            return register_error("An error occurred. Please try again.");
        }
    };

    // Create user
    let first_name = form.first_name.trim().to_string();
    let result = sqlx::query_scalar::<_, i64>(
        r#"
        INSERT INTO users (email, first_name, password_hash, roles, permissions, email_verified)
        VALUES ($1, $2, $3, '{"user"}', '{}', false)
        RETURNING id
        "#
    )
    .bind(form.email.to_lowercase())
    .bind(&first_name)
    .bind(&password_hash)
    .fetch_one(state.db())
    .await;

    match result {
        Ok(user_id) => {
            // Auto-login after registration
            session.1.user_id = Some(user_id);
            session.1.user_name = Some(first_name.clone());

            // Return OOB response with updated nav, content, and flash
            let template = AuthSuccessTemplate {
                user_id: Some(user_id),
                user_name: Some(first_name.clone()),
                flash_messages: vec![FlashMessage::success(format!("Welcome, {first_name}!"))],
            };
            Html(template.render().unwrap()).into_response()
        }
        Err(e) => {
            tracing::error!("Failed to create user: {}", e);
            register_error("Failed to create account. Please try again.")
        }
    }
}

/// POST /logout - Clear session and logout
pub async fn logout(
    mut session: SessionExtractor,
) -> Response {
    // Clear user info from session
    session.1.user_id = None;
    session.1.user_name = None;

    // Return OOB response with login form, updated nav, and flash
    let template = LogoutSuccessTemplate {
        error: None,
        flash_messages: vec![FlashMessage::info("You have been logged out.")],
    };
    Html(template.render().unwrap()).into_response()
}
