//! Authentication handlers with `SQLite` database integration
//!
//! Provides login, registration, and logout functionality with:
//! - Argon2id password hashing
//! - Session-based authentication
//! - Flash messages for user feedback
//! - Form validation
//! - HTMX out-of-band swaps for seamless updates

use crate::AppState;
use acton_dx::prelude::*;
use acton_dx::auth::{FlashMessage, hash_password, verify_password};
use askama::Template;
use axum::{
    extract::State,
    response::{Html, IntoResponse, Response},
    Form,
};
use serde::Deserialize;

/// User row from `SQLite` database
#[derive(Debug, Clone, sqlx::FromRow)]
struct UserRow {
    id: i64,
    #[allow(dead_code)]
    email: String,
    password_hash: String,
}

// =============================================================================
// Templates
// =============================================================================

#[derive(Template)]
#[template(path = "auth/login.html")]
pub struct LoginTemplate {
    pub user_id: Option<i64>,
    pub error: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

#[derive(Template)]
#[template(path = "auth/register.html")]
pub struct RegisterTemplate {
    pub user_id: Option<i64>,
    pub error: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

/// Nav partial for OOB swap after auth state changes
#[derive(Template)]
#[template(path = "partials/nav.html")]
pub struct NavPartial {
    pub user_id: Option<i64>,
}

/// Flash messages partial for OOB swap
#[derive(Template)]
#[template(path = "partials/flash.html")]
pub struct FlashPartial {
    pub flash_messages: Vec<FlashMessage>,
}

/// Home content partial for post-login/register content swap
#[derive(Template)]
#[template(path = "partials/home_content.html")]
pub struct HomeContentPartial {
    pub user_id: Option<i64>,
}

/// Login form partial for post-logout content swap
#[derive(Template)]
#[template(path = "partials/login_content.html")]
pub struct LoginContentPartial {
    pub error: Option<String>,
}

// =============================================================================
// Form Data
// =============================================================================

#[derive(Debug, Deserialize)]
pub struct LoginForm {
    pub email: String,
    pub password: String,
}

#[derive(Debug, Deserialize)]
pub struct RegisterForm {
    pub email: String,
    pub password: String,
    pub password_confirm: String,
}

// =============================================================================
// Handlers
// =============================================================================

/// GET /login - Show login form
pub async fn login_form(
    session: SessionExtractor,
) -> Html<String> {
    let template = LoginTemplate {
        user_id: session.1.user_id,
        error: None,
        flash_messages: session.1.flash_messages,
    };
    Html(template.render().unwrap())
}

/// POST /login - Process login
pub async fn login(
    State(state): State<AppState>,
    mut session: SessionExtractor,
    Form(form): Form<LoginForm>,
) -> Response {
    // Validate form
    if form.email.is_empty() || form.password.is_empty() {
        let template = LoginTemplate {
            user_id: None,
            error: Some("Email and password are required".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    // Find user by email
    let user = match sqlx::query_as::<_, UserRow>(
        "SELECT id, email, password_hash FROM users WHERE email = ?"
    )
    .bind(form.email.to_lowercase())
    .fetch_optional(state.db())
    .await
    {
        Ok(Some(user)) => user,
        Ok(None) => {
            let template = LoginTemplate {
                user_id: None,
                error: Some("Invalid email or password".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
        Err(e) => {
            tracing::error!("Database error during login: {}", e);
            let template = LoginTemplate {
                user_id: None,
                error: Some("An error occurred. Please try again.".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
    };

    // Verify password
    if matches!(verify_password(&form.password, &user.password_hash), Ok(true)) {
        // Set user ID in session
        session.1.user_id = Some(user.id);
        let flash = FlashMessage::success("Successfully logged in!");

        // Return OOB swaps: main content + nav update + flash messages
        let home = HomeContentPartial { user_id: Some(user.id) };
        let flash_partial = FlashPartial { flash_messages: vec![flash] };

        let response = format!(
            r#"{}
<nav id="main-nav" hx-swap-oob="true">
    <a href="/">Home</a>
    <span class="nav-user">Logged in</span>
    <button hx-post="/logout" hx-target="#main-content" class="nav-logout">Logout</button>
</nav>
<div id="flash-messages" hx-swap-oob="true">{}</div>"#,
            home.render().unwrap(),
            flash_partial.render().unwrap()
        );
        Html(response).into_response()
    } else {
        let template = LoginTemplate {
            user_id: None,
            error: Some("Invalid email or password".to_string()),
            flash_messages: vec![],
        };
        Html(template.render().unwrap()).into_response()
    }
}

/// GET /register - Show registration form
pub async fn register_form(
    session: SessionExtractor,
) -> Html<String> {
    let template = RegisterTemplate {
        user_id: session.1.user_id,
        error: None,
        flash_messages: session.1.flash_messages,
    };
    Html(template.render().unwrap())
}

/// POST /register - Process registration
pub async fn register(
    State(state): State<AppState>,
    mut session: SessionExtractor,
    Form(form): Form<RegisterForm>,
) -> Response {
    // Validate form
    if form.email.is_empty() {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Email is required".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    if form.password.len() < 8 {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Password must be at least 8 characters".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    if form.password != form.password_confirm {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Passwords do not match".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    // Check if email already exists
    let exists = sqlx::query_scalar::<_, i32>(
        "SELECT 1 FROM users WHERE email = ?"
    )
    .bind(form.email.to_lowercase())
    .fetch_optional(state.db())
    .await;

    if matches!(exists, Ok(Some(_))) {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Email already registered".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    // Hash password
    let password_hash = match hash_password(&form.password) {
        Ok(hash) => hash,
        Err(e) => {
            tracing::error!("Password hashing failed: {}", e);
            let template = RegisterTemplate {
                user_id: None,
                error: Some("An error occurred. Please try again.".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
    };

    // Create user
    let result = sqlx::query(
        r#"
        INSERT INTO users (email, password_hash, roles, permissions, email_verified)
        VALUES (?, ?, '["user"]', '[]', 0)
        "#
    )
    .bind(form.email.to_lowercase())
    .bind(&password_hash)
    .execute(state.db())
    .await;

    match result {
        Ok(result) => {
            let user_id = result.last_insert_rowid();

            // Auto-login after registration
            session.1.user_id = Some(user_id);
            let flash = FlashMessage::success("Account created successfully! Welcome!");

            // Return OOB swaps: main content + nav update + flash messages
            let home = HomeContentPartial { user_id: Some(user_id) };
            let flash_partial = FlashPartial { flash_messages: vec![flash] };

            let response = format!(
                r#"{}
<nav id="main-nav" hx-swap-oob="true">
    <a href="/">Home</a>
    <span class="nav-user">Logged in</span>
    <button hx-post="/logout" hx-target="#main-content" class="nav-logout">Logout</button>
</nav>
<div id="flash-messages" hx-swap-oob="true">{}</div>"#,
                home.render().unwrap(),
                flash_partial.render().unwrap()
            );
            Html(response).into_response()
        }
        Err(e) => {
            tracing::error!("Failed to create user: {}", e);
            let template = RegisterTemplate {
                user_id: None,
                error: Some("Failed to create account. Please try again.".to_string()),
                flash_messages: vec![],
            };
            Html(template.render().unwrap()).into_response()
        }
    }
}

/// POST /logout - Clear session and logout
pub async fn logout(
    mut session: SessionExtractor,
) -> Response {
    // Clear user ID from session
    session.1.user_id = None;
    let flash = FlashMessage::info("You have been logged out.");

    // Return OOB swaps: login form + nav update + flash messages
    let login = LoginContentPartial { error: None };
    let flash_partial = FlashPartial { flash_messages: vec![flash] };

    let response = format!(
        r#"{}
<nav id="main-nav" hx-swap-oob="true">
    <a href="/">Home</a>
    <a href="/login">Login</a>
    <a href="/register">Register</a>
</nav>
<div id="flash-messages" hx-swap-oob="true">{}</div>"#,
        login.render().unwrap(),
        flash_partial.render().unwrap()
    );
    Html(response).into_response()
}
